

# 0. 手写代码

## 1. 单例模式

```java
//饿汉式
public class Singleton {
    private static final Singleton SINGLETON = new Singleton();
    private Singleton() {}  //此类不能被实例化
    public static Singleton getInstance() {
        return SINGLETON;
    }
}

//懒汉式
public class Singleton {
    private static Singleton singleton;
    private Singleton() {}  //此类不能被实例化
    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}

//静态内部类
public class Singleton {
    private Singleton() {} //构造方法是私有的，从而避免外界利用构造方法直接创建任意多实例。
    public static Singleton getInstance() {
        return Holder.SINGLETON;
    }
    private static class Holder {
       private static final Singleton SINGLETON = new Singleton();
    }
}

//双重检查
public class SingletonClass { 
  	private volatile static SingletonClass instance = null; 
  	private SingletonClass() {} 
  	public static SingletonClass getInstance() { 
    	if (instance == null) { 
      		synchronized (SingletonClass.class) { 
        		if (instance == null) { 
          			instance = new SingletonClass(); 
        		} 
     	 	} 
    	} 
    	return instance; 
  	}   
}
```

## 2. 多线程

```java
FutureTask<Integer> task3 = new FutureTask<>(() -> {
	log.debug("hello");
	return 100;
});
new Thread(task3, "t3").start();
Integer result = task3.get();
log.debug("结果是:{}", result);
```

```java
 class MyThreadDemo extends Thread {
        @Override
        public void run(){
			//多线程执行的方法
            for(int i=0;i<10;i++){
                System.out.println("输出:"+i);
            }
        }
  }

 @Test
    public void runTest2(){ 
        MyThreadDemo thread1=new MyThreadDemo();
        thread1.start();
	}



class MyRunnableDemo implements Runnable{
        @Override
        public void run() {
            for(int i=0;i<10;i++){
                System.out.println("输出Runnable:"+i);
            }
        }
    }

@Test
    public void test1(){
        MyRunnableDemo myRunnableDemo1=new MyRunnableDemo();
        Thread thread1=new Thread(myRunnableDemo1);
        thread1.start();
    }
```

### 银行转账案例

```java
public class Bank {
		private final double[] accounts;
		public Bank(int n, double initialBalance) {
				accounts = new double[n];
				for (int i = 0; i < accounts.length; i++) {
						accounts[i] = initialBalance;
				}
		}
  
  	public void transfer(int from, int to, double amount) {
				if (accounts[from] < amount) {
						return;
				}
				System.out.println(Thread.currentThread());
				accounts[from] -= amount;
				System.out.printf("%f from %d to %d ", amount, from, to);
				accounts[to] += amount;
				System.out.println("total:" + getTotalBalance());
		}
  
		public double getTotalBalance() {
				double sum = 0d;
				for (int i = 0; i < accounts.length; i++) {
						sum += accounts[i];
				}
				return sum;
		}
		public int getAccountSize() {
				return accounts.length;
		}
}
```

```java
public class TransferRunnable implements Runnable {

		private Bank bank;
		private int fromAccount = 0;
		private double maxAmount = 0;

		public TransferRunnable(Bank b, int fromAccount, double maxAmount) {
				this.bank = b;
				this.fromAccount = fromAccount;
				this.maxAmount = maxAmount;
		}

		@Override
		public void run() {
				double amount = maxAmount * Math.random();
				int toAccount = (int) ((int) bank.getAccountSize() * Math.random());
				bank.transfer(fromAccount, toAccount, amount);
				try {
						Thread.sleep((long) (100L * Math.random()));
				} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
				}
		}
}
```

```java
public class Test {
		public static void main(String[] args) {
				Bank bank = new Bank(100, 1000);
				for (int i = 0; i < 3; i++) {
						TransferRunnable transferRunnable = new TransferRunnable(bank, i, 1000);
						Thread thread = new Thread(transferRunnable);
						thread.start();
				}
		}
}

Thread[Thread-0,5,main]
Thread[Thread-2,5,main]
Thread[Thread-1,5,main]
430.796266 from 0 to 75
714.274395 from 1 to 88
849.880218 from 2 to 33
total:98435.8453871716
total:99150.11978192833
total:100000.0
```

```java
public synchronized void transfer(int from, int to, double amount) {

		if (accounts[from] < amount) {
				return;
		}
		System.out.println(Thread.currentThread());
		accounts[from] -= amount;
		System.out.printf("%f from %d to %d ", amount, from, to);
		accounts[to] += amount;
		System.out.println("total:" + getTotalBalance());
}

public double getTotalBalance() {
		double sum = 0d;
		for (int i = 0; i < accounts.length; i++) {
				sum += accounts[i];
		}
		return sum;
}

public int getAccountSize() {
		return accounts.length;
}


输出结果：
Thread[Thread-0,5,main]
187.754955 from 0 to 50 total:100000.0
Thread[Thread-1,5,main]
282.138799 from 1 to 90 total:100000.0
Thread[Thread-2,5,main]
217.089515 from 2 to 86 total:100000.00000000001
```

## 3. 阻塞队列

```java
/**
 * @author yz
 * @version 1.0
 * @date 2020/10/31 11:24
 */
public class YzBlockingQuery {

    private Object[] tab; //队列容器
    private int takeIndex; //出队下标
    private int putIndex; //入队下标
    private int size;//元素数量
    private ReentrantLock reentrantLock = new ReentrantLock();
    private Condition notEmpty;//读条件
    private Condition notFull;//写条件

    public YzBlockingQuery(int tabCount) {
        if (tabCount <= 0) {
            new NullPointerException();
        }
        tab = new Object[tabCount];
        notEmpty = reentrantLock.newCondition();
        notFull = reentrantLock.newCondition();
    }

    public boolean offer(Object obj) {
        if (obj == null) { throw new NullPointerException(); }
        try {
            //获取锁
            reentrantLock.lock();
            //队列已满
            while (size==tab.length){
                System.out.println("队列已满");
                //堵塞
                notFull.await();
            }
            tab[putIndex]=obj;
            if(++putIndex==tab.length){
                putIndex=0;
            }
            size++;
            //唤醒读线程
            notEmpty.signal();
            return true;
        } catch (Exception e) {
            //唤醒读线程
            notEmpty.signal();
        } finally {
            reentrantLock.unlock();
        }
        return false;
    }


    public Object take(){
        try {
            reentrantLock.lock();
            while (size==0){
                System.out.println("队列空了");
                //堵塞
                notEmpty.await();
            }
            Object obj= tab[takeIndex];
            //如果到了最后一个，则从头开始
            if(++takeIndex==tab.length){
                takeIndex=0;
            }
            size--;
            //唤醒写线程
            notFull.signal();
            return obj;
        }catch (Exception e){
            //唤醒写线程
            notFull.signal();
        }finally {
            reentrantLock.unlock();
        }
        return null;
    }


    public static void main(String[] args) {
        Random random = new Random(100);
        YzBlockingQuery yzBlockingQuery=new YzBlockingQuery(5);
        Thread thread1 = new Thread(() -> {
            for (int i=0;i<100;i++) {
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                yzBlockingQuery.offer(i);
                System.out.println("生产者生产了："+i);
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i=0;i<100;i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Object take = yzBlockingQuery.take();
                System.out.println("消费者消费了："+take);
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

```java
public class MyBlockQueue {
    private List<Integer> queue = new ArrayList<>();//用数组实现的话定义索引变量就可以
    private volatile int curSize;
    private volatile int capacity;
    private Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();//不满
    private final Condition notNull = lock.newCondition();//不空

    public MyBlockQueue(int capacity) {
        this.capacity = capacity;
    }

    public void add(int value){
        lock.lock();
        try{
            while(curSize == capacity){
                //等待队列不满
                notFull.await();
            }
            queue.add(value);
            ++curSize;
//            System.out.println("入队成功");
            notNull.signal();//通知队列不为空
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            lock.unlock();
        }
    }

    public Integer take(){
        lock.lock();
        Integer x = null;
        try{
            while(curSize == 0){
                //等待队列不为空
                notNull.await();
            }
            x = queue.remove(0);
            curSize--;
            notFull.signal();
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            lock.unlock();
        }
        return x;
    }

    public static void main(String[] args) {
        MyBlockQueue queue = new MyBlockQueue(5);
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName()+"消费"+queue.take());
            }
        }).start();
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                queue.add(i);
                System.out.println(Thread.currentThread().getName()+"生产"+i);
            }

        }).start();
    }
}
```

## 4. 手写线程池

```java
public class MyThreadPool {

    /** 利用阻塞队列实现生产者-消费者模式 */
    BlockingQueue<Runnable> workQueue;

    /** 保存内部工作线程 */
    List<WorkThread> workThreadList = new ArrayList<>();

    MyThreadPool(int poolSize, BlockingQueue<Runnable> workQueue) {
        this.workQueue = workQueue;
        for (int i = 0; i < poolSize; i++) {
            WorkThread workThread = new WorkThread();
            workThread.start();
            workThreadList.add(workThread);
        }
    }

    void execute(Runnable command) {
        // 放入任务，如果没有空间，则阻塞等待
        // try catch部分省略
        workQueue.put(command);
    }


    class WorkThread extends Thread {
        @Override
        public void run() {
            // 循环取任务并执行
            while (true) {
                Runnable task = null;
                // 获取阻塞队列的第一个任务，并删除
                // 如果没有元素，则会阻塞等待
                // try catch部分省略
                task = workQueue.take();
                task.run();
            }
        }
    }

    public static void main(String[] args) {
        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(5);
        MyThreadPool pool = new MyThreadPool(2, workQueue);
        for (int i = 0; i < 10; i++) {
            int num = i;
            pool.execute(()->{
                System.out.println("线程 " + num + " 执行");
            });
        }
    }
}


```

```java
package com.concurrent.pool;
 
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
 
public class MySelfThreadPool {
	//默认线程池中的线程的数量
	private static final int WORK_NUM = 5;
	//默认处理任务的数量
	private static final int TASK_NUM = 100;
	
	private int workNum;//线程数量
	
	private int taskNum;//任务数量
	
	private final Set<WorkThread> workThreads;//保存线程的集合
	
	private final BlockingQueue<Runnable> taskQueue;//阻塞有序队列存放任务
	
	
	public MySelfThreadPool() {
		this(WORK_NUM, TASK_NUM);
	}
 
 
	public MySelfThreadPool(int workNum, int taskNum) {
		if (workNum <= 0) workNum = WORK_NUM;
		if (taskNum <= 0) taskNum = TASK_NUM;
		taskQueue = new ArrayBlockingQueue<>(taskNum);
		this.workNum = workNum;
		this.taskNum = taskNum;
		workThreads = new HashSet<>();
		//启动一定数量的线程数，从队列中获取任务处理
		for (int i=0;i<workNum;i++) {
			WorkThread workThread = new WorkThread("thead_"+i);
			workThread.start();
			workThreads.add(workThread);
		}
	}
	
	/**
	 * 线程池执行任务的方法，其实就是往BlockingQueue中添加元素
	 * @param task
	 */
	public void execute(Runnable task) {
		try {
			taskQueue.put(task);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void destroy() {
		System.out.println("ready close thread pool...");
		if (workThreads == null || workThreads.isEmpty()) return ;
		for (WorkThread workThread : workThreads) {
			workThread.stopWork();
			workThread = null;//help gc
		}
		workThreads.clear();
	}
	
	/**
	 * 线程池中的工作线程，直接从BlockingQueue中获取任务
	 * 然后执行任务而已
	 * blockQueue为阻塞队列
	 *
	 */
	private class WorkThread extends Thread{
		public WorkThread(String name) {
			super();
			setName(name);
		}
		
		@Override
		public void run() {
			while (!interrupted()) {
				try {
					Runnable runnable = taskQueue.take();//获取任务
					if (runnable !=null) {
						System.out.println(getName()+" ready execute:"+runnable.toString());
						runnable.run();//执行任务
					}
					runnable = null;//help gc
				} catch (Exception e) {
					interrupt();
					e.printStackTrace();
				}
			}
		}
		
		
		public void stopWork() {
			interrupt();
		}
	}
}



package com.concurrent.pool;
 
public class TestMySelfThreadPool {
	
	private static final int TASK_NUM = 50;//任务的个数
 
	public static void main(String[] args) {
		MySelfThreadPool myPool = new MySelfThreadPool(3,50);
		for (int i=0;i<TASK_NUM;i++) {
			myPool.execute(new MyTask("task_"+i));
		}
		
	}
	
	static class MyTask implements Runnable{
		
		private String name;
		public MyTask(String name) {
			this.name = name;
		}
		
		public String getName() {
			return name;
		}
 
		public void setName(String name) {
			this.name = name;
		}
 
 
		@Override
		public void run() {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("task :"+name+" end...");
			
		}
		
		@Override
		public String toString() {
			// TODO Auto-generated method stub
			return "name = "+name;
		}
	}
}
```

## 5. 生产者消费者模式

```java
/**
 * 一个初始值为零的变量，两个线程对其交替操作，一个加1一个减1，
 */
class Cakes {
    private int cakeNumber = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void increment() throws InterruptedException {
        lock.lock();
        try{
            //判断 (多线程判断用while)
            while(cakeNumber != 0){
                //等待 不能生产
                condition.await();
            }
            //进行操作（生产蛋糕）
            cakeNumber++;
            System.out.println(Thread.currentThread().getName()+"烹饪" + cakeNumber+"个蛋糕");
            //通知唤醒
            condition.signalAll();
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            lock.unlock();
        }
    }

    public void decrement() throws InterruptedException {
        lock.lock();
        try{
            //判断 (多线程判断用while)
            while(cakeNumber ==0){
                //等待 不能消费
                condition.await();
            }
            //进行操作
            cakeNumber--;
            System.out.println(Thread.currentThread().getName()+"吃完蛋糕，还剩" + cakeNumber+"个蛋糕");
            //通知唤醒
            condition.signal();
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            lock.unlock();
        }
    }
}
public class ProdConsumerTraditionDemo {
    public static void main(String[] args) {
        Cakes cake = new Cakes();
        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    cake.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"厨师").start();
        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                try {
                    cake.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"顾客").start();
    }
}
```

## 6. 实现自旋锁

```java
复制代码
 1 public class SpinLockDemo {
 2     //原子引用线程
 3     AtomicReference<Thread> atomicReference = new AtomicReference<>();
 4 
 5     public void myLock(){
 6         Thread thread = Thread.currentThread(); 
 8         while(!atomicReference.compareAndSet(null,thread)){
 9             //匹配则不进入循环 获取锁后!=null进入循环 释放锁后被set为null退出循环
16         }
18     }
19 
20     public void myUnlock(){
21         Thread thread = Thread.currentThread();
22         atomicReference.compareAndSet(thread,null);
24     }
25     public static void main(String[] args) {
26         SpinLockDemo spinLockDemo = new SpinLockDemo();
27         new Thread(()->{
28             spinLockDemo.myLock();
35             spinLockDemo.myUnlock();
36         },"A").start();
42         new Thread(()->{
43             spinLockDemo.myLock();
50             spinLockDemo.myUnlock();
51         },"B").start();
52     }
53 }
```

## 7. 多线程交替打印abc

```java
 1 import java.util.concurrent.locks.Condition;
 2 import java.util.concurrent.locks.Lock;
 3 import java.util.concurrent.locks.ReentrantLock;
 4 
10 class Plat{
11     private int id = 1; // 编号
12     private Lock lock = new ReentrantLock();
13     private Condition a = lock.newCondition();
14     private Condition b = lock.newCondition();
15     private Condition c = lock.newCondition();
16     public void printA(){
17         lock.lock();
18         try{
19             while (id != 1){
20                 a.await();
21             }
22             System.out.println("A");
23             id = 2;
24             b.signal();
25         }catch(Exception e){
26             e.printStackTrace();
27         }finally{
28             lock.unlock();
29         }
30     }
31     public void printB(){
32         lock.lock();
33         try{
34             while (id != 2){
35                 b.await();
36             }
37             System.out.println("B");
38             id = 3;
39             c.signal();
40         }catch(Exception e){
41             e.printStackTrace();
42         }finally{
43             lock.unlock();
44         }
45     }
46     public void printC(){
47         lock.lock();
48         try{
49             while (id != 3){
50                 c.await();
51             }
52             System.out.println("C");
53             id = 1;
54             a.signal();
55         }catch(Exception e){
56             e.printStackTrace();
57         }finally{
58             lock.unlock();
59         }
60     }
61 
62 }
63 public class PrintAbc {
64     public static void main(String[] args) throws InterruptedException {
65         Plat plat = new Plat();
66         for (int i = 0; i < 3; i++) {
67             new Thread(()->{
68                 plat.printA();
69             }).start();
70             new Thread(()->{
71                 plat.printB();
72             }).start();
73             new Thread(()->{
74                 plat.printC();
75             }).start();
76         }
77     }
78 }
```

## 8. 交替打印1-10000

```java
public class PrintOneThousand {
    private static volatile Integer counter = 0;
    private static Object monitor = new Object();

    public static void main(String[] args) {
        new Thread(()->{
            while (true){
                synchronized (monitor){
                    if (counter % 2 != 0){
                        continue;
                    }
                    int i = ++counter;
                    if (i > 1000){
                        return;
                    }
                    System.out.println("奇数线程："  + i);
                    try {
                        monitor.notify();
                        monitor.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();

        new Thread(()->{
            while (true){
                synchronized (monitor){
                    if (counter % 2 == 0){
                        continue;
                    }
                    int i = ++counter;
                    if (i > 1000){
                        return;
                    }
                    System.out.println("偶数线程："  + i);
                    try {
                        monitor.notify();
                        monitor.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
```

```java
public class PrintOneThousand{
    private static volatile  boolean loopForOdd = true;
    private static volatile  boolean loopForEven = true;
    private static volatile int counter = 1;
    private static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        // 先启动奇数线程
        loopForOdd = false;
        new Thread(()->{
            while (flag) {
                while (loopForOdd) {

                }
                int counter = PrintOneThousand.counter;
                if (counter > 100) {
                    flag=false;
                    break;
                }
                System.out.println("奇数线程：" + counter);

                PrintOneThousand.counter++;
                // 修改volatile，通知偶数线程停止循环，同时，准备让自己陷入循环
                loopForEven = false;
                loopForOdd = true;
            }
        }).start();

        new Thread(()->{
            while (flag) {
                while (loopForEven) {

                }
                int counter = PrintOneThousand.counter;
                if (counter > 100) {
                    flag=false;
                    break;
                }
                System.out.println("偶数线程：" + counter);
                PrintOneThousand.counter++;
                // 修改volatile，通知奇数线程停止循环,同时，准备让自己陷入循环
                loopForOdd = false;
                loopForEven = true;
            }
        }).start();
    }
}
```



# 1. 冒泡排序

## **原理**：

比较两个相邻的元素，将值大的元素交换至右端。

## **思路**：

依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。

第一趟比较完成后，最后一个数一定是数组中最大的一个数，所以第二趟比较的时候最后一个数不参与比较；

第二趟比较完成后，倒数第二个数也一定是数组中第二大的数，所以第三趟比较的时候最后两个数不参与比较；

依次类推，每一趟比较次数-1；

……

## 示例：

举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   

第一趟排序：

　　　　第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1

　　　　第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1

　　　　第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1

　　　　第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1

　　　　第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9

　　　　第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9

\---------------------------------------------------------------------

第二趟排序：

　　　　第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9

　　　　第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9

　　　　第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9

　　　　第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9

　　　　第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9

\---------------------------------------------------------------------

第三趟排序：

　　　　第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9

　　　　第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9

　　　　第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9

　　　　第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9

\---------------------------------------------------------------------

第四趟排序：

　　　　第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9

　　　　第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9

　　　　第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9

\---------------------------------------------------------------------

第五趟排序：

　　　　第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9

　　　　第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9

\---------------------------------------------------------------------

最终结果：1  2  3  6  8  9

由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即

```java
for(int i=1;i<arr.length;i++){
    for(int j=1;j<arr.length-i;j++){
    //交换位置
}
```

## 优点：

冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。

## 时间复杂度：

1. 如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。

2. 如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
   $$
   C_{MAX}=\frac{n(n-1)}{2}=O(n^2)
   \\
   M_{MAX}=\frac{3n(n-1)}{2}=O(n^2)
   $$

冒泡排序的最坏时间复杂度为：O(n2) 。

综上所述：冒泡排序总的平均时间复杂度为：O(n2) 。

## 代码：

```java
/*
 * 冒泡排序
 */
public class BubbleSort {
　　public static void main(String[] args) {
　　　　int[] arr={6,3,8,2,9,1};
　　　　System.out.println("排序前数组为：");
　　　　for(int num:arr){
　　　　　　System.out.print(num+" ");
　　　　}
　　　　for(int i=0;i<arr.length-1;i++){//外层循环控制排序趟数
　　　　　　for(int j=0;j<arr.length-1-i;j++){//内层循环控制每一趟排序多少次
　　　　　　　　if(arr[j]>arr[j+1]){
　　　　　　　　　　int temp=arr[j];
　　　　　　　　　　arr[j]=arr[j+1];
　　　　　　　　　　arr[j+1]=temp;
　　　　　　　　}
　　　　　　}
　　　　} 
　　　　System.out.println();
　　　　System.out.println("排序后的数组为：");
 　　　　for(int num:arr){
 　　　　　　System.out.print(num+" ");
 　　　　} 
　　}
 }
```



```java
public void bubbleSort(int[] nums){
    for(int i = 0; i < nums.length - 1; i++){
        for(int index = 0; index < nums.length - 1 - i; index++){
            if(nums[index] > nums[index + 1]){
                swap(nums, index, index + 1);
            }
        }
    }
}

优化：当序列已经有序时仍会进行不必要的比较，可以设置一个标志记录是否有元素交换，没有直接结束。
public void betterBubbleSort(int[] nums){
    boolean swap;
    for(int i = 0; i < nums.length - 1; i++){
        swap = true;
        for(int index = 0; i < nums.length - 1 - i; index++){
            if(nums[index] > nums[index + 1]){
                swap(nums, index, index + 1);
            	swap = false;
            }
        }
        if(swap) break;
    }
}
```







# 2. 快速排序

## 思路：

快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135248.jpg)

## 代码：

```java
public class QuickSort {
    public static void quickSort(int[] arr,int low,int high){
        if(low>high){
            return;
        }
        int i=low;
        int j=high;
        //temp就是基准位
        int pivot = arr[low];

        while (i<j) {
            //先看右边，依次往左递减
            while (pivot <= arr[j] && i < j) {
                j--;
            }
            //再看左边，依次往右递增
            while (pivot >= arr[i] && i < j) {
                i++;
            }
            //如果满足条件则交换
            if (i < j) {
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
        //最后将基准为与i和j相等位置的数字交换
         arr[low] = arr[i];
         arr[i] = pivot;
        //递归调用左半数组
        quickSort(arr, low, j - 1);
        //递归调用右半数组
        quickSort(arr, j + 1, high);
    }
 
    public static void main(String[] args){
        int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};
        quickSort(arr, 0, arr.length-1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}



//解法2：返回下标和利用下标
	private int partition(int[] nums, int low, int high){
        int pivot = nums[low];
        int i = low;
        int j = high;
        while(i < j){
            while(i < j && nums[j] >= pivot){
                j--;
            }
            while(i < j && nums[i] <= pivot){
                i++;
            }
            if(i < j){
                int temp = nums[j];
                nums[j] = nums[i];
                nums[i] = temp;
            }
        }
        nums[low] = nums[i];
        nums[i] = pivot;
        return i;
    }
	//利用
	public static void main(String[] args){
        int low = 0;
        int high = arr.length - 1;
        while(low < high){
            int index = partition(arr, low, high);
            if(index > 要找的某位k) high = index - 1;
            if(index < k) low = index + 1;
            if(index == k) break;
        }
    }
```

## 优化

### 一. 快速排序基准选择

1. 固定基准

找一个基准值base，然后一趟排序后让base左边的数都小于base，base右边的数都大于等于base。再分为两个子数组的排序。如此递归下去。

2. 随机基准

在数组几乎有序时，快排性能不好（因为每趟排序后，左右两个子递归规模相差悬殊，大的那部分最后很可能会达到O(n^2)）。

解决：基准值随机地选取，而不是每次都取第一个数。这样就不会受“几乎有序的数组”的干扰了。但是对“几乎乱序的数组”的排序性能可能会稍微下降，至少多了排序前交换的那部分，乱序时这个交换没有意义...有很多“运气”成分..

3. 三数取中法

由于随机基准选取的随机性，使得它并不能很好的适用于所有情况(即使是同一个数组，多次运行的时间也大有不同)。目前，比较好的方法是使用三数取中选取基准。它的思想是：选取数组开头，中间和结尾的元素，通过比较，选择中间的值作为快排的基准。其实可以将这个数字扩展到更大(例如5数取中，7数取中等)。这种方式能很好的解决待排数组基本有序的情况，而且选取的基准没有随机性。

例如：序列`[1][1][6][5][4][7][7]`，三个元素分别是`[1]、[5]、[7]`，此时选择`[5]`作为基准。

第一趟：`[1][1][4][5][6][7][7]`

三数取中算法如下：

```java
int NumberOfThree(int arr[],int low,int high)
{
	int mid = low + ((high - low) >> 1);//右移相当于除以2
 
	if (arr[mid] > arr[high])
	{
		Swap(arr[mid],arr[high]);
	}
	if (arr[low] > arr[high])
	{
		Swap(arr[low],arr[high]);
	}
	if (arr[mid] > arr[low]) 
	{
		Swap(arr[mid],arr[low]);
	}
	//此时，arr[mid] <= arr[low] <= arr[high]
	return arr[low];
}
```

### 二. 序列长度到达一定大小时，采用插入排序

当快排达到一定深度后，划分的区间很小时，再使用快排的效率不高。当待排序列的长度达到一定数值后，可以使用插入排序。当待排序列长度为5~20之间，此时使用插入排序能避免一些有害的退化情形。

```java
template <class T>
void QSort(T arr[],int low,int high)
{
    int pivotPos;
    if (high - low + 1 < 10)
    {
        InsertSort(arr,low,high);
        return;
    }
    if(low < high)
    {
        pivotPos = Partition(arr,low,high);
        QSort(arr,low,pivotPos-1);
        QSort(arr,pivotPos+1,high);
    }
}
```

### 三. 尾递归优化

快排算法和大多数分治排序算法一样，都有两次递归调用。但是快排与归并排序不同，归并的递归则在函数一开始， 快排的递归在函数尾部，这就使得快排代码可以实施尾递归优化。使用尾递归优化后，可以缩减堆栈的深度，由原来的O(n)缩减为O(logn)。

尾递归概念：

如果一个函数中所有递归形式的调用都出现在函数的末尾，当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。

尾递归原理：

当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。

### 四. 聚集元素

### 五. 多线程处理快排

### 六. 快速排序继续优化：两路快排

在最开始的普通快速排序说过，让基准值base左边的都比base小，而base右边的都大于等于base。等于base的这些会聚集到右侧(或者稍微改改大小关系就会聚集到左侧)。总之就会聚集到一边。这样在数组中重复数字很多的时候，就又会导致两边子递归规模差距悬殊的情况。这时想把等于base的那些数分派到base两边，而不是让他们聚集到一起。

（注：测试代码的时候，最好把插入排序那部分注视掉，向我下面代码中那样...不然数据量小于k=16的时候执行的是插入排序.....）



### 七. 快速排序继续优化：两路快排 不用swap, 用直接赋值

上面的两路在找到大于base的值和小于base的值时，用的是swap()方法来进行交换。两数交换涉及到第三个变量temp的操作，多了读写操作。接下来用直接赋值的方法，把小于的放到右边，大于的放到左边，当i和j相遇时，那个位置就是base该放的地方。至此一趟完成。递归即可。



### 八. 快速排序继续优化：当大量数据，且重复数多时，用三路快排

把数组分为三路，第一路都比base小，第二路都等于base，第三路都大于base。

用指针从前到后扫描，如果：

1.cur指向的数小于base，那么：交换arr[cur]和arr[i]的值，然后i++,cur++。

2.cur指向的数等于base,  那么：cur++

3.cur指向的数大于base，那么：交换arr[cur]和arr[j]的值，然后j--。

当cur > j的时候说明三路都已经完成。



# 3. 希尔排序

希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。


## 思路

希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：

```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序：

```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：

```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：

```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序（此时就是简单的插入排序了）

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135240.jpg)

## 代码：

```java
/**
 * 希尔排序演示
 * @author Lvan
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {5, 1, 7, 3, 1, 6, 9, 4};
        shellSort(arr);

        for (int i : arr) {
            System.out.print(i + "\t");
        }
    }

    private static void shellSort(int[] arr) {
        //step:步长
        for (int step = arr.length / 2; step > 0; step /= 2) {
            //对一个步长区间进行比较 [step,arr.length)
            for (int i = step; i < arr.length; i++) {
                int value = arr[i];
                int j;

                //对步长区间中具体的元素进行比较
                for (j = i - step; j >= 0 && arr[j] > value; j -= step) {
                    //j为左区间的取值，j+step为右区间与左区间的对应值。
                    arr[j + step] = arr[j]; 
                }
                //此时step为一个负数，[j + step]为左区间上的初始交换值
                arr[j + step] = value;  
            }
        }
    }
}
```

优化后：

希尔排序的分割的内部是插入排序把，插入排序的话如果待插入的元素比有序数组的最大元素大的话，是有序的元素后移，而不是直接将有序的元素和待插入的元素交换位置。所以，这个shell排序可以优化，本来是比较然后后移赋一次值的一步，变成了比较加赋值交换（会赋值3次，包括辅助变量）。这样肯定会造成性能上的浪费。

```java

package DataStr;
 
import java.util.Arrays;
 
public class ShellSort {
	public static void main(String[] args) {
		int[] arr = getRandomArray(15, 0, 10);
		System.out.println("希尔排序前："+Arrays.toString(arr));
		shellSort(arr);
		System.out.println("希尔排序后："+Arrays.toString(arr));
	}
	
	/**
	 * 希尔排序
	 * @param arr 待排数组
	 */
	public static void shellSort(int[] arr) {
		for(int gap=arr.length/2; gap>0; gap/=2) { /*步长逐渐减小*/
			for(int i=gap; i<arr.length; i++) { /*在同一步长内*/
				//同一步长内排序方式是插入排序
				int temp = arr[i], j; //待排元素
				//j-gap代表有序数组中最大数的下标，j-pag表示有序数组的前一个元素，减pag是减去偏移量就是步长
				for(j=i; j>=gap && temp<arr[j-gap]; j-=gap)
					arr[j] = arr[j-gap]; //原有序数组最大的后移一位
				arr[j] = temp; //找到了合适的位置插入
			}
		}
	}
    
	public static int[] getRandomArray(int n, int rangeL, int rangeR) {
		int[] arr = new int[n];
		for(int i=0; i<n; i++) {
			arr[i] = (int)(Math.random() * (rangeR - rangeL +1)) + rangeL;
		}
		return arr;
    }
}
```

# 4. 直接插入排序

## 1. 思路

把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只有一个元素，无序表中有n-1个元素；排序过程即每次从无序表中取出第一个元素，将它插入到有序表中，使之成为新的有序表，重复n-1次完成整个排序过程。

## 2. 实例

```
　　0.初始状态 3，1，5，7，2，4，9，6（共8个数）
　　   有序表：3；无序表：1，5，7，2，4，9，6
　　
　　1.第一次循环，从无序表中取出第一个数 1，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，3；无序表：5，7，2，4，9，6

　　2.第二次循环，从无序表中取出第一个数 5，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，3，5；无序表：7，2，4，9，6

　　3.第三次循环，从无序表中取出第一个数 7，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，3，5，7；无序表：2，4，9，6

　　4.第四次循环，从无序表中取出第一个数 2，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，2，3，5，7；无序表：4，9，6

　　5.第五次循环，从无序表中取出第一个数 4，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，2，3，4，5，7；无序表：9，6

　　6.第六次循环，从无序表中取出第一个数 9，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，2，3，4，5，7，9；无序表：6

　　7.第七次循环，从无序表中取出第一个数 6，把它插入到有序表中，使新的数列依旧有序
　　   有序表：1，2，3，4，5，6，7，9；无序表：（空）
```

## 3. 代码

```java
public class InsertSort {
    public static void insertSort(int [] array){
        for(int i=0;i<array.length;i++){
            //有序[0,i)
            //无序[i,array.length)
            int j=i-1;
            int key=array[i];
            for(;j>=0 && key<array[j];j--){
                array[j+1]=array[j];
            }
            array[j+1]=key;
        }
    }
 
    public static void main(String[] args) {
        int[] arr={9,3,1,5,2,4,3,8};
        insertSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```







# 5. 简单选择排序

## 1. 思路

在要排序的一组数中，选出最小的一个数与第一个位置的数交换；

然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。

## 2. 实例

**例：3，1，4，2**

**第1次·：1，3，4，2**

**第2次：1，2，4，3**

**第3次：1，2，3，4**

## 3. 代码

```java

public class SimpleSelectSort {
	public void selectionSort(int[] arr) {
		// 需要遍历获得最小值的次数
		// 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列
		for (int i = 0; i < arr.length - 1; i++) {
			int min = i; // 用来保存最小值得索引
			// 寻找第i个小的数值
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[min] > arr[j])
					min = j;
			}
 
			// 若min有变化，就将找到的第i个小的数值与第i个位置上的数值交换
			if (min != i) {
				int temp = arr[min];
				arr[min] = arr[i];
				arr[i] = temp;
			}
		}
	}
}
```

## 4. 分析

- **时间复杂度：O（n2）**

- **空间复杂度：O（1）**

- **稳定性：不稳定**

- **复杂性：简单**

  

# 6. 堆排序

## 1. 定义

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135223.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135229.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]  

小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  

## 2. 思路

ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了


### **步骤一 构造初始堆。**

**将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。**

a.假设给定无序序列结构如下

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135143.png)

2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135112.png)

3.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135134.png)

这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135052.png)

此时，我们就将一个无需序列构造成了一个大顶堆。

### **步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。**

**然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

a.将堆顶元素9和末尾元素4进行交换

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135040.png)

b.重新调整结构，使其继续满足堆定义

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135153.png)

后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135158.png)

再简单总结下堆排序的基本思路：

　　a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

　　b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135204.gif)

## 3. 代码

```java
 
import java.util.Arrays;
/**
 * 
 * @author Administrator
 *
 */
public class HeapSort {
    public static void main(String []args){
        int []arr = {7,6,7,11,5,12,3,0,1};
        System.out.println("排序前："+Arrays.toString(arr));
        sort(arr);
        System.out.println("排序前："+Arrays.toString(arr));
    }
 
    public static void sort(int []arr){
        //1.构建大顶堆
        for(int i = arr.length / 2 - 1; i >= 0; i--){
            //从第一个非叶子结点从下至上，从右至左调整结构
            adjustHeap(arr, i, arr.length);
        }
        //2.调整堆结构+交换堆顶元素与末尾元素
        for(int j = arr.length-1; j > 0; j--){
            swap(arr, 0, j);//将堆顶元素与末尾元素进行交换
            adjustHeap(arr, 0, j);//重新对堆进行调整
        }
    }
 
    /**
     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）
     * @param arr
     * @param i
     * @param length
     */
    public static void adjustHeap(int[] arr, int i, int length){
        int temp = arr[i];//先取出当前元素i
        for(int k = i * 2 + 1;k < length; k = k * 2 + 1){//从i结点的左子结点开始，也就是2i+1处开始
            if(k + 1 < length && arr[k] < arr[k+1]){//如果左子结点小于右子结点，k指向右子结点
                k++;
            }
            if(arr[k] > temp){//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;//将temp值放到最终的位置
    }
 
    /**
     * 交换元素
     * @param arr
     * @param a
     * @param b
     */
    public static void swap(int[] arr,int a ,int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
```

结果：

```java
排序前：[7, 6, 7, 11, 5, 12, 3, 0, 1]
排序前：[0, 1, 3, 5, 6, 7, 7, 11, 12]
```

算法复杂度：O(nlogn)

# 7. 归并排序

## 1. 思路

归并排序采用的是分治(divide-and-conquer)法思想。

（1）基本思想：将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序，最终将排好序的子集合合并成为所要求的排好序的集合。

（2）执行过程：

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135328.png)

2. 代码

```java
public class Main {
 
	public static void main(String[] args) {
		int[] arr = {11,44,23,67,88,65,34,48,9,12};
		int[] tmp = new int[arr.length];    //新建一个临时数组存放
		mergeSort(arr,0,arr.length-1,tmp);
		for(int i=0;i<arr.length;i++){
			System.out.print(arr[i]+" ");
		}
	}
	
	public static void merge(int[] arr,int low,int mid,int high,int[] tmp){
		int i = 0;
		int j = low,k = mid+1;  //左边序列和右边序列起始索引
		while(j <= mid && k <= high){
			if(arr[j] < arr[k]){
				tmp[i++] = arr[j++];
			}else{
				tmp[i++] = arr[k++];
			}
		}
		//若左边序列还有剩余，则将其全部拷贝进tmp[]中
		while(j <= mid){    
			tmp[i++] = arr[j++];
		}
		
		while(k <= high){
			tmp[i++] = arr[k++];
		}
		
		for(int t=0;t<i;t++){
			arr[low+t] = tmp[t];
		}
	}
 
	public static void mergeSort(int[] arr,int low,int high,int[] tmp){
		if(low<high){
			int mid = (low+high)/2;
			mergeSort(arr,low,mid,tmp); //对左边序列进行归并排序
			mergeSort(arr,mid+1,high,tmp);  //对右边序列进行归并排序
			merge(arr,low,mid,high,tmp);    //合并两个有序序列
		}
	}
}
```

## 2. 分析

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135334.png)

# 8. 基数排序

基数排序(radix sort)又称桶排序（bucket sort），相对于常见的比较排序，基数排序是一种分配式排序，即通过将所有数字分配到应在的位置最后再覆盖到原数组完成排序的过程。我在上一篇讲到的[计数排序](http://www.cnblogs.com/developerY/p/3166462.html)也属于这种排序模式，上一篇结尾处提到了计数排序的稳定性，即排序前和排序后相同的数字相对位置保持不变。今天我们要说的基数排序就要利用到排序稳定性这一点。

## 1. 思路

我们回想一下我们小时候是怎么学习比较数字大小的？我们是先比位数，如果一个位数比另一个位数多，那这个数肯定更大。如果位数同样多，就按位数递减依次往下进行比较，哪个数在这一位上更大那就停止比较，得出这个在这个位上数更大的数字整体更大的结论。当然我们也可以从最小的位开始比较，这其实就对应了基数排序里的MSD(most significant digital)和LSD(least significant digital)两种排序方式。

​     想清楚了这一点之后，我们就要考虑如何存储每一位排序结果的问题了，首先既然作为分配式排序，联想计数排序，每一位排序时存储该次排序结果的数据结构应该至少是一个长度为10的数组（对应十进制该位0-9的数字）。同时可能存在以下情况：原数组中所有元素在该位上的数字都相同，那一维数组就没法满足我们的需要了，我们需要一个10*n(n为数组长度)的二维数组来存储每次位排序结果。熟悉计数排序结果的读者可能会好奇：为什么不能像计数排序一样，在每个位置只存储出现该数字的次数，而不存储具体的值，这样不就可以用一维数组了？这个我们不妨先思考一下，在对基数排序分析完之后再来看这个问题。

​      现在我们可以存储每次位排序的结果了，为了在下一位排序前用到这一位排序的结果，我们要将桶里排序的结果还原到原数组中去，然后继续对更改后的原数组执行前一步的位排序操作，如此循环，最后的结果就是数组内元素先按最高位排序，最高位相同的依次按下一位排序，依次递推。得到排序的结果数组。

## 2. 算法

1. **初始化：**构造一个10*n的二维数组，一个长度为n的数组用于存储每次位排序时每个桶子里有多少个元素。
2. **循环操作：**从低位开始（我们采用LSD的方式），将所有元素对应该位的数字存到相应的桶子里去（对应二维数组的那一列）。然后将所有桶子里的元素按照桶子标号从小到大取出，对于同一个桶子里的元素，先放进去的先取出，后放进去的后取出（保证排序稳定性）。这样原数组就按该位排序完毕了，继续下一位操作，直到最高位排序完成。

下面给出一个实例帮助理解：

我们现有一个数组：73, 22, 93, 43, 55, 14, 28, 65, 39, 81

下面是排序过程（二维数组里每一列对应一个桶，因为桶空间没用完，因此没有将二维数组画全）：

1.按个位排序

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 81   | 22   | 73   | 14   | 55   |      |      | 28   | 39   |
|      |      |      | 93   |      | 65   |      |      |      |      |
|      |      |      | 43   |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |

 

按第一位排序后数组结果：

81,22,73,93,43,14,55,65,28,39

可以看到数组已经按个位排序了。

2根据个位排序结果按百位排序

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      | 14   | 22   | 39   | 43   | 55   | 65   | 73   | 81   | 93   |
|      |      | 28   |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |      |

取出排序结果：

14,22,28,39,43,55,65,73,81,93

可以看到在个位排序的基础上，百位也排序完成（对于百位相同的数子，如22,28，因为个位已经排序，而取出时也保持了排序的稳定性，所以这两个数的位置前后是根据他们个位排序结果决定的）。因为原数组元素最高只有百位，原数组也完成了排序过程。

## 3. 代码

我们现在来看看之前遗留的两个问题：为什么不能用一维数组，一定要用二维数组这样的类似桶的结构来存储中间位排序结果？其实之所以要写这个问题，是因为我觉得这个问题是理解基数排序的关键。基数排序本身原理很简单，但是实现中有两个问题需要考虑：1.怎么保留前一位的排序结果，这个问题用之前提到的排序稳定性可以解决。2.怎么关联该位排序结果和原数组元素，二维数组正是为了解决这个问题使用的办法。在计数排序里，虽然保留了所有相等的元素的相对位置，但是这些相等的元素在计数排序里实际是没有差别的，因此我们可以只保存数组里有多少个这样的元素即可。而基数排序里不同，有些元素虽然在某一位上相同，但是他们其他位上很可能不同，如果只保存该位上有多少个5或者多少个6，那关于元素其他位的信息就都丢弃了，这样也就没法对这些元素更高位进行排序了。

​     弄清基数排序的过程后，我们来看看这个算法的时间复杂度是多少？每次循环遍历数组将元素放在指定位置Θ(n)，在从桶中取出数据Θ(n)，循环d次（d是位数），时间复杂度就是Θ(r*n)

```java
package sort;

public class RadixSort {
private static void radixSort(int[] array,int d)
{
    int n=1;//代表位数对应的数：1,10,100...
    int k=0;//保存每一位排序后的结果用于下一位的排序输入
    int length=array.length;
    int[][] bucket=new int[10][length];//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里
    int[] order=new int[length];//用于保存每个桶里有多少个数字
    while(n<d)
    {
        for(int num:array) //将数组array里的每个数字放在相应的桶里
        {
            int digit=(num/n)%10;
            bucket[digit][order[digit]]=num;
            order[digit]++;
        }
        for(int i=0;i<length;i++)//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果
        {
            if(order[i]!=0)//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中
            {
                for(int j=0;j<order[i];j++)
                {
                    array[k]=bucket[i][j];
                    k++;
                }
            }
            order[i]=0;//将桶里计数器置0，用于下一次位排序
        }
        n*=10;
        k=0;//将k置0，用于下一轮保存位排序结果
    }
}
    
public static void main(String[] args)
{
    int[] A=new int[]{73,22, 93, 43, 55, 14, 28, 65, 39, 81};
    radixSort(A, 100);
    for(int num:A)
    {
        System.out.println(num);
    }
}
```

# 9. 总结

![](https://gitee.com/wychz/PicGoBed/raw/master/img/20200717135341.png)

## 1. 时间复杂度

(1)平方阶(O(n2))排序
　　各类简单排序:直接插入、直接选择和冒泡排序；
 (2)线性对数阶(O(nlog2n))排序
　　快速排序、堆排序和归并排序；
 (3)O(n1+§))排序,§是介于0和1之间的常数。

​		希尔排序

(4)线性阶(O(n))排序
　　基数排序，此外还有桶、箱排序。

说明：

当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；

而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；

原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。


## 2. 稳定性

排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。 

稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；

稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序

## 3. 使用准则

每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。

选择排序算法的依据

影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：

1．待排序的记录数目n的大小；

2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；

3．关键字的结构及其分布情况；

4．对排序稳定性的要求。

设待排序元素的个数为n.

1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。

```
 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
 堆排序 ：  如果内存空间允许且要求稳定性的
 归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。
```

2）当n较大，内存空间允许，且要求稳定性 =》归并排序

3）当n较小，可采用直接插入或直接选择排序。

    直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。
    直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序

5）一般不使用或不直接使用传统的冒泡排序。

6）基数排序
它是一种稳定的排序算法，但有一定的局限性：
　　1、关键字可分解。
　　2、记录的关键字位数较少，如果密集更好
　　3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。

